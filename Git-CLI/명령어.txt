pwd : 현재 폴더의 위치를 확인한다. ex ) /C/박종혁/스터디
ls -a : 현재 폴더의 파일목록을 확인한다. (-a의 옵션을 이용해 숨김 파일도 볼 수 있다.)
ls -al : 현재폴더의 파일들을 만든날짜 정보까지 다보여준다 
cd : 홈폴더로 이동한다.
cd 폴더이름 : 특정 위치의 디렉토리로 이동한다.
cd .. : 현재폴더의 상위 폴더로 이동한다.
mkdir 새폴더이름 : 현재 폴더아래에 새로운 폴더를 만든다.
echo "..." > a.txt : a라는 파일에 ...이라는 문장을 폴더를 만들어 추가한다. >하나면 안에 내용 전부 삭제 후 추가
			>>두개면 삭제 없이 그냥 추가
echo "..." : 큰 따옴표 안에 텍스트를 보여준다.
cat (폴더, 파일) / (폴더,파일) : 폴더,파일의 내용을 확인한다 / 폴더안에 폴더를 확인한다.
git init : 깃 파일 생성
git status : 워킹트리의 상태를 보여준다ㅎ+
git status -s : git status보다 짧게 요약해서 알려준다(변경된 파일이 많을 때 유용하다.)
git remote add origin 원격저장소주소 : origin이라는 이름을 가진 원격저장소를 하나 연결한다.
git remote -v : 원격저장소 목록 확인
git fetch [원격저장소 별명] [브랜치이름] : 원격저장소의 브랜치와 커밋들을 로컬저장소로 동기화함
git pull = git fetch + git merge

git config --global 옵션명 : git의 옵션 설정
git add 파일이름 : 파일이름을 추적한다(tracked상태)
cat 파일이름 : 파일이름 안에 있는 내용을 보여준다.
git commit : 하게되면 비주얼 스튜디오가 켜지는데 커밋 메세지 입력 후 저장하고 닫으면 커밋메세지까지 저장됨
git commit -a : 스테이징 없이 바로 커밋 (add 없이)
git log : 현재 브랜치의 커밋이력을 본다.
git log -n : 최신 n개의 커밋을 본다.	
	(git log) --oneline : 커밋 메세지를 한줄로 요약해서 봄
	(git log) --graph : 커밋 옆에 브랜치 흐름을 그래프로 보여줌
	(git log) --decorate : 브랜치와 태그 등의 참조를 간결히 표현
git fetch (원격저장소별명) (브랜치이름) : 원격저장소의 브랜치와 커밋들을 로컬저장소와 동기화한다. 옵션생략 시 모든 원격저장소에서 모든 브랜치를 가져온다.
git push -u origin(원격저장소별명) master(브랜치이름) : 현재 브랜치에 푸쉬한다, 즉 -u옵션으로 브랜치의 업스트림을 등록할수 있다.
git push : 현재의 커밋만 올린다.
git clone 저장소주소 새로운폴더명 : 저장소 주소를 해당폴더를 만들면서 클론한다.
git branch -v : 브랜치들을 보여준다 -v를 붙일 경우 마지막 커밋도 함께 보여준다
git branch[-f] <브랜치이름> [커밋체크섬] 새로운 브랜치를 생성함 커밋체크섬을 주지 않으면 현재 HEAD에 만듬 
		이미 있는 브랜치를 다른 커밋으로 옮기고 싶을 때는 f옵션 사용
git branch -r : 원격 저장소에 있는 브랜치를 보여준다
git branch 브랜치이름 : 브랜치이름을 가진 브랜치 생성
git checkout 브랜치이름 : 브랜치이름으로 체크아웃한다.
git checkout  -b 브랜치1이름 (브랜치2이름): 특정 커밋에서 브랜치1를 새로 생성하고 동시에 체크아웃 (브랜치2 기재 시 브랜치 2커밋에서 브랜치를 생성한다)		
git merge 브랜치이름 : 브랜치이름을 병합한다.(병합 커밋이 많이 일어난다)
git rebase 브랜치이름 : 내 브랜치를 브랜치이름에 재배치시킨다.
git branch -d 브랜치이름 : 브랜치이름을 삭제시킨다.(HEAD브랜치나 병합되지 않은 브랜치는 삭제 X)
git branch -D 브랜치이름 : 브랜치이름을 강제로 삭제시킨다. 
git tag -a -m 메세지 태그이름 : 태그이름이라는 태그를 생성한다. 메세지와 태그 이름은 필수이다.
git push 원격저장소별명 브랜치이름 : 원격저장소에 태그이름을 푸쉬한다.
git merge --abort : merge 취소
git clean -f -d <파일이름 또는 폴더이름> : untracked 상태의 파일만 삭제한다. (파일이름을 기재하지 않으면 모두 삭제함) -f : 파일 -d : 디렉토리
git reset --(hard, mixed, soft) <커밋체크섬> : 모두 unracked 파일은 건드리지 않음
	hard : 현재브랜치(HEAD), stage, 워킹트리까지 다 초기화
	mixed : 워킹트리는 그대로 둠, 현재브랜치(HEAD), stage, 초기화
	soft : 현재브랜치만 초기화
	커밋체크섬을 넣어준다면 리셋한걸 다시 되돌려준다 즉 지운걸 복구 시켜줌 커밋체크섬이나, 브랜치 번호 ex)HEAD@{4}
(예를 들어 하나의 커밋 이전단계로 reset했다가 다시 그 커밋을 보고싶으면 이 커밋의 체크섬을 넣어라)
git reset --hard 이동할커밋체크섬(HEAD~2) : 커밋을 되돌린다. (HEAD~2 : 2번째 이전 커밋으로 돌아간다 / HEAD^2 두번째 부모 병합했을 때 다른 부모 브랜치로 이동하기 위해)
git reset 파일이름 : 스테이지 영역에 있는 파일을 스테이지에서 내린다(untracked상태)
git diff : 워킹트리나 스테이지, 레퍼지토리에 있는 파일들의 차이점을 보여준다.
git diff --check : 공백문자의 변경사항까지 보여줌
git add --patch <파일명>: 추적된 파일의 경우 원하는 부분만 커밋 가능 
	파일명 :   y : 현재 변경사항을 스테이징 함
		n : 현재 변경사항을 스테이징 하지 않음
		e : 직접 편집
		q : 변경사항 무시 후 종료
git stash <-u> : .git/refs 폴더 안에 stash라고 새로운 파일이 생기고 그 파일에 임시저장됨 저장된 파일은 push 할 수 없다.< -u 옵션 사용시 unstage 파일도 임시저장가능 
                     - but 한번이라도 git에 올려진 파일들만 가능하다)
	stash pop <stash 객체> : drop + apply 이며, 객체를 다시 워킹트리에 반영하고 스택에 저장된 stash 객체는 삭제
	stash drop <stash 객체> : 지정한 stash 객체 삭제	
	stash apply <stash 객체> : 워킹트리에 반영하지만, 객체는 삭제되지 않음
	stash clear : 스택의 모든 stash 객체 삭제
	stash branch 브랜치이름 : 브랜치 이름이라는 브랜치를 만들며 stash에 있는 파일을 적용시킨다.
	stash list : stash의 리스트를 보여준다.
git cherry-pick <커밋 체크섬> : 선언된 하나의커밋을 가져와서 합친다.ㄴ
git reflog : 작업 이력을 다보여준다 log 같은 경우는 현재 commit 이력을보여주면 reflog는 리셋 된 상태작업까지 모두 보여줌
git commit --amend : HEAD커밋이 가르키고 있는, 즉 현재 커밋을 수정하기 위해(원격저장소에 이미 push 되어있으면 하지마라) !! ammend 하면 체크섬 아이디도 바뀜





내부동작원리(해쉬코드로 조작)
add 시 즉 스테이지 화 하면 .git 폴더에 index 파일이 생성되는데 확인해보면 GIt index이다 이 말은 스테이지의 다른말이 index이며  index파일이 곧 Git의 스테이지이다.
git ls-files --stage : 스테이지 파일의 내용 확인 = 해쉬코드 값이 나옴
git show (해쉬코드값) : 해당 해쉬코드값의 내용을 확인 할 수 있다.
git hash-object (파일이름) : 파일의 해쉬코드값을 보여줌 (untracked 상태에서 해쉬코드 값 확인가능)
.git에 object파일을 살펴보면 생성한 파일들의 해쉬코드 값의 앞 두글자를 딴 폴더들이 생성된다.
또한 스테이지화 된 상태에서 커밋을 하게되면 커밋의 해쉬코드값 두글자를 딴 폴더가 또다르게 생성된다. 
정리하자면 커밋 폴더도 따로 생기고 파일에 대한 해쉬코드 폴더도 따로따로 생성되는걸 확인할 수 있는데 이것은 곧 워킹트리 스테이지 커밋에 다 동일하게 파일들이 존재한다는 내용이다.
git cat-file -t ((체크섬) : 체크섬으로 객체의 종류를 알 수 있다.
git cat-file (객체타입) (체크섬) : 해당 객체의 내용을 볼 수 있다.
그런데 여기서 중요한 점은 이렇게 커밋해쉬코드폴더와 스테이지해쉬코드폴더 말고도 하나의 객체가 더 생성되어있는 걸 볼 수 있는데,
이 폴더는 트리객체이다. 
트리 객체는 커밋 상태 최종버전을 뜻하는 버전인데, 
커밋을 하면 스테이지의 객체로 트리(스테이지파일 = 트리)가 만들어진다. 그리고 커밋에는 커밋 메시지와 함꼐 트리 객체가 같이 포함된다.

자 그러면 수동으로 트리를 생성해보자
git write-tree 를 하면 랜덤 해쉬값을 가진 트리생성
git ls-tree 해쉬값(트리객체) : 생성된 트리 객체 확인

echo "..." | git commit-tree 해쉬값(트리객체) -p HEAD : 트리로 커밋을 생성 (그러면 커밋 해쉬값이 나올 것이다.)
이때 커밋로그를 확인하면 커밋이 생성되지 않은 걸 확인할 수 있을 것이다. 그 이유는 우리가 수동으로 만든 HEAD 값을 갱신하지 않았기 때문이다.
따라서 갱신 또한 수동으로 해주어야 하는데, .git 파일의 HEAD 폴더를 분석할 필요가 있다.
HEAD폴더를 들어가 보게 되면 ref의 master 값이 이전 커밋을 가르키고 있는데 이것을 수동으로 바꾸어야 한다.
git update-ref refs/heads/master 해쉬값(커밋해쉬값) : 직접 커밋을 업데이트
cat .git/refs/heads/master으로 확인하면 커밋해쉬값이 바뀐걸 볼수 있꼬
git log --oneline을 하게 되면 커밋이 생성된것을 볼 수 있다.


git 의 4대 오브젝트(객체타입) -- 시험 나온데
- blob : 바이너리 데이터 자체 저장, 파일명은 SHA1 40자
- tree : 디렉토리 내용(파일 이름 속성 등)을 저장
- commit : working tree의 snapshot (blob + tree)
- tag

.git 폴더안에 폴더와 파일들 해석
refs/heads/ 안에 폴더들은 브랜치를 뜻한다.
HEAD파일 : 현재 가르키고 있는 브랜치를 뜻한다. 만약 cat 해서 읽어보면 refs 폴더 안에 heads의 브랜치르 가르킬 것이다.
index파일 : 스테이지