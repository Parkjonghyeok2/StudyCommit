스프링 부트 2.7 이상부터는 한글 꺠짐.
build.gradle 에서 2.6 이하로 버전 다운.


return "index" == templates의 inex.html 파일을 자동으로 찾아가는데 이것은 스프링의 리졸브?라는 녀석이 해준다
application.properties

2.6 버전에서 실행할 때 Invalid mapping pattern detected 오류 발생시
요청 경로를 ControllerHandler에 매칭시키기 위한 전략의 기본 값
즉,  spring.mvc.pathmatch.matching-strategy 기본 값이 
ant_path_matcher 에서 path_pattern_parser 로 변경된다.
따라서 application.properties에 
spring.mvc.pathmatch.matching-strategy=ant_path_matcher 를 작성해준다.

- 디버그 레벨로 쿼리 출력
	- logging.level.org.hibernate.SQL=DEBUG

- 쿼리문 가시성 확대
	- spring.jpa.properties.hibernate.format_sql=true 

- 파라미터 변수값 보여주기
	- logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

- DB URL 고정 설정
	- spring.datasource.url=jdbc:h2:mem:testdb

- DB 유니크 URL 생성 비활성화
	- spring.datasource.generate-unique-name=false

========

스프링 개념

일반적으로 웹 서버에서는 각 클라이언트당 스레드의 개념으로 접근한다.
따라서 3인의 유저가 동시에 서버에 접속하면 3개의 new 객체가 생겨 관리되는데,
스프링에서는 Beans 파일 즉, xml에 한 번만 정의해두고 각 스레드가 해당 자원을
공유하면서 결론적으로 서버의 힙 공간에는 초기 세팅 단 하나의 객체만 생성된다.

Bean
	Spring에서는 직접 new를 이용하여 생성한 객체가 아닌
	Spring에 의하여 관리당하는 자바 객체를 사용.
	이렇게 Spring에 의하여 생성되고 관리되는 자바 객체를 Bean 이라고 칭함.

DI 
	Dependency Injection (의존성 주입)
	DI(의존관계 주입)는 객체가 의존하는 또 다른 객체를 외부에서 선언하고
	이를 주입받아 사용하는 것이다.
	IoC 컨테이너에 빈으로 등록되어 있어야 의존성 주입이 가능하다.

@GetMapping(" ")		// 주소 입력시 입력 경로로 진입

@Entity			// DB의 테이블을 의미
@Id			// PK를 의미
@GeneratedValue		// 영속성을 위한 기본키 설정 전략
	- IDENTITY : Mysql에서 주로 사용. 기본키 생성을 데이터베이스에 위임한다.
	- SEQUENCE : Oracle 에서 주로 사용. 시퀀스를 조회하는 쿼리를 사용한다.
	- TABLE : 모든 DBMS에서 사용. 키 생성 전용 테이블을 만들어 시퀀스 대체.
		성능으로 인해 권장되지 않는다.

@ToString		// (Lombok) ToString.

@Data			// (Lombok) Getter, Setter, ToString 등을 모두 설정
			   엔티티에 사용시 컨트롤러에서 다양한 메서드 사용 가능.

@Autowired		// 스프링이 관리하는 Bean을 자동으로 매핑해줌.

@AllArgsConstructor	// (Lombok) 생성자 효과

@NoArgsConstructor	// (Lombok) 기본 생성자

@Slf4j			// (Lombok) 로깅 기능 추가

@PathVariable		// url 경로상 변수를 설정 가능

// API
일반 @Controller 와 @RestController 의 경우
Controller 는 뷰 템플릿 페이지 자체를 반환하는 반면,
RestController 는 JSON 객체, 데이터를 보낸다.
즉, 전송하는 데이터 형식이 다르다.

@RequestBody		// JSON 객체를 서버에서 받기 위해 사용.
			   매개변수에 사용해준다.

@Transactional		// 해당 메소드를 트랜잭션으로 묶어 오류 발생시 
			   메서드 수행 이전 시간으로 롤백시켜준다.
========

메서드

findById()		// 매개변수를 기본키로 가진 데이터를 가져온다.

findAll() 		// 모든 데이터를 가져온다.

데이터 타입 불일치
	- 간혹 repository.find ~ 메서드를 사용해 데이터를 저장하려고 할 때,
	  데이터 타입이 일치하지 않을 때가 있다. 이 때는 저장하려는 데이터를
	  형변환 해주거나, 데이터가 저장될 변수의 타입을 바꾸어준다.

	- 또는 Repository에서 상속받은 부모 메서드를 재정의하여
	  원하는 타입으로 바꾸어 줄 수 있다.

HTTP
	- Get		// Read
	- POST		// Create
	- PATCH/PUT	// Update
	- DELETE		// Delete
	- HTML 환경에서는 GET과 POST 만을 지원
	- a 태그는 GET 방식을 제공

RedirectAttributes
	- 리다이렉트가 발생하면 원래 페이지에서 보낸 요청이 끊어지고,
	  새로운 GET 요청이 만들어진다. 따라서 이전에 수행된 모델 데이터는 소멸한다.
	- 리다이렉트는 HTTP GET 방식이다.
	- 리다이렉트의 패턴은 POST/Redirect/GET
	- 리다이렉트 시 URL에 파라미터가 보이지 않는다.
	- FlashAttributes
		- 리다이렉트 발생 전 모든 플래시 속성을 세션에 복사한다.
		- 리다이렉션 이후에 저장된 플래시 속성을 세션에서
		  모델로 이동시킨다.
		- addFlashAttribute() 메서드는 리다이렉트 직전 플래시에 저장하는
		  메서드이다. 리다이렉트 이후에는 소멸한다.

매개변수로 null 값 전달	/	java.lang.IllegalArgumentException
dto, eintity 파일에 생성자가 작성되어 있는지, 데이터 타입이 맞는지 반드시 확인할것..

ResponseEntity.statue()
	- 반환타입. 메서드의 반환타입으로 설정하면 함수의 리턴값에
	  오류 코드를 실어 보낼 수 있다	.
	.build()메서드는 Response body 에다가 아무 내용없는 값을 던진다.
	즉 결과 값 창에 아무것도 안뜬다.

    public String save(@RequestParam("memberEmail") String memberEmail) {
여기서 RequestParam은 form태그로 받아온 name 값을 자바 변수로 선언하기 위한 애노테이션

Request Body : 클라이언트가 API로 데이터를 보낼때 사용되는 데이터
Response Body : API가 request의 응답으로 클라이언트에게 보내는 데이터


test코드 작성법
	test를 진행하고 싶은 메서드에서 우클릭 -> Generate -> test
	그러면 test 프로젝트에 본 프로젝트의 구조와 대칭으로 클론되어 생긴다.



일반적으로 html 에서 a태그를 이용한 href 이동은 HTTP 메서드 중 GET에 속한다